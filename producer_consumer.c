#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched/signal.h>
#include <linux/semaphore.h>
#include <linux/kthread.h>
#include <linux/timekeeping.h>
#include <linux/slab.h>

//The input parameters for the arguments that are received by teh kernel module.

int buffSize;
int prod;
int cons;
int uuid;

//module_param is used to pass input arguments onto the kernel module.

module_param(buffSize, int, 0);
module_param(prod, int, 0 );
module_param(cons, int, 0);
module_param(uuid, int, 0);

//This is the template for making lists that store task_structs of processes.

struct task_struct_list {
	struct task_struct* task;
	struct task_struct_list* next; 
	};

//This is the template of making the shared buffer for the storage of task_structs of the processes.
	
struct buffer {

	int capacity;
	struct task_struct_list* list;
};

//The shared buffer of the two threads.

struct buffer *buf = NULL;

//Definition of the mutex, full, and empty semaphores.

struct semaphore mutex;
struct semaphore full;
struct semaphore empty;

//The total CPU run time is stored in this variable.
u64 total_seconds;

//Keeps track of the number of consumers used so far.
int consumed = 0;

//Pointers for the task_structs of the processes in each thread.

struct task_struct *pThread;
int pThreadPID;
struct task_struct_list *cThreads = NULL;

/*
producer(void *arg) -- Producer thread function

Goes through a list of processes and adds processes
generated by user uuid to a shared buffer.
*/
static int producer(void *arg) {
	//Pointer used to traverse the task_structs of all processes.
	struct task_struct *ptr;
	int process_counter = 0;

	//Adds processes into buffer
	for_each_process(ptr) {
		if (ptr->cred->uid.val == uuid) {	// Process was generated by uuid
			process_counter++;	// Increment total processes
		
			if (down_interruptible(&empty))	// Acquire lock for empty
				break;
			if (down_interruptible(&mutex))	// Acquire lock for mutex
				break;	

			//Critical section - Add current task to buffer
			if (buf->list == NULL) {	// No tasks in buffer
				// Create new task_struct_list and add
				struct task_struct_list *newT;
				newT = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
				newT->task = ptr;
				buf->list = newT; //Add the item to the shared buffer.

				buf->capacity++;
				printk(KERN_INFO "[%s] Produced Item#-%d at buffer index:%d for PID:%d", current->comm, process_counter, buf->capacity, newT->task->pid);	//Print the details of the newly produced item by the kernel module.
			}
			else {	// If the Tasks exist in buffer
				// Find it in the end of the shared buffer.
				struct task_struct_list *temp = buf->list;
				
				while (temp->next != NULL) {
					temp = temp->next;
				}
				// Create new task_struct pointer for it.
				struct task_struct_list *newT;
				newT = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
				newT->task = ptr;
				temp->next = newT;

				buf->capacity++;
				printk(KERN_INFO "[%s] Produced Item#-%d at buffer index:%d for PID:%d\n", current->comm, process_counter, buf->capacity, newT->task->pid);	//Same as above, print the produced item in the kernel module.
			}

			// Release locks
			up(&mutex);
			up(&full);
		}
	}

	return 0;	// Success
}

/*
consumer(void *arg) -- Consumer thread function

Takes tasks from the buffer (when available) and adds their elapsed time to
the total elapsed time.
*/
static int consumer(void *arg) {
	int consumedCount = 0;

	//Start infinite loop until stop
	while (!kthread_should_stop()) {
		if (down_interruptible(&full))	// Acquire lock from "full"
			break;
		if (down_interruptible(&mutex))	// Acquire lock from "mutex"
			break;


		//Check to skip critical section
		if (kthread_should_stop()) {
			return 0;
		}

		// If the buffer contains at least 1 task
		if (buf != NULL && buf->list != NULL && buf->capacity > 0) {
			//Critical section - Take a task and add to elapsed time
			struct task_struct_list *temp = buf->list;
			buf->list = buf->list->next;
			u64 time_elapsed = ktime_get_ns() - temp->task->start_time;
			u64 elapsed_seconds = time_elapsed / 1000000000;
			u64 minutes = elapsed_seconds / 60;
			u64 hours = minutes / 60;
			u64 remaining_seconds = elapsed_seconds % 60;
			total_seconds = total_seconds + time_elapsed;

			// increment amount consumed by this thread and all threads
			consumedCount++;
			consumed++;
			printk(KERN_INFO "[%s] Consumed Item#-%d on buffer index:%d for PID:%d Elapsed Time- %llu:%llu:%llu\n", current->comm, consumedCount, buf->capacity, temp->task->pid, hours, minutes, remaining_seconds);

			buf->capacity--;	// Task has been consumed, it has been removed from the shar ebuffer.

			// Release locks
			up(&mutex);	
			up(&empty);
		}

	}

	return 0;	// Success
}

/*
procon_init(void) -- Module Initializing Method

Initializes variables used in the program.
Includes:
+ semaphores	(mutex,full,empty)
+ buffer		(buf)
+ producer		(pThread)
+ consumers		(cThreads)

Then prints PIDs of consumer threads
*/
static int __init procon_init(void) {
	int err;
	
	printk(KERN_INFO "Starting producer_consumer module\n");

	//Initialize Semaphores
	sema_init(&mutex, 1);
	sema_init(&full, 0);
	sema_init(&empty, buffSize);

	buf = kmalloc(sizeof(struct buffer), GFP_KERNEL);

	// START THREADS

	// Run the producer thread if tasked to.
	if (prod == 1) {
		pThread = kthread_run(producer, NULL, "Producer-1");
		pThreadPID = pThread->pid;

		if (IS_ERR(pThread)) {	// Error in creation the Production thread.
			printk(KERN_INFO "ERROR: Cannot create producer thread\n");
			err = PTR_ERR(pThread);
			pThread = NULL;
			return err;
		}
	}
	
	// Run the consumer thread if tasked to..
	int i = 0;
	while (i < cons) {
		// Construct task_struct lists for the procedures traversed by the consumer thread. 
		struct task_struct_list *cThread = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
		cThread->task = kthread_run(consumer, NULL, "Consumer-%d", i);

		if (IS_ERR(cThread->task)) {	// Error in creating the consumer thread.
			printk(KERN_INFO "ERROR: Cannot create consumer thread\n");
			err = PTR_ERR(cThread->task);
			cThread->task = NULL;
			return err;
		}

		// Attach new process as head of cThreads list
		cThread->next = cThreads;
		cThreads = cThread;

		i++;
	}

	// Go through each process in cThreads and print PID
	struct task_struct_list *cThr = cThreads;
	while (cThr != NULL) {
		printk(KERN_INFO "consumer thread PID %d\n", cThr->task->pid);
		cThr = cThr->next;
	}

	return 0;	// Successs
}

/*
procon_exit(void) -- Module exit Method

Frees memory for all threads, awakes and releases semaphores
*/
static void __exit procon_exit(void) {
	// Free buffer memory
	struct task_struct_list *temp = buf->list;
	while (temp != NULL) {
		struct task_struct_list *tbr = temp;
		temp = temp->next;
		kfree(tbr);
	}
	kfree(buf);

	printk(KERN_INFO "Stopping producer thread PID-%d\n", pThreadPID);

	// Halt consumer threads
	int i = cons;
	struct task_struct_list *cThread = cThreads;
	// Wait on all the semaphores.
	while (cThread != NULL) {
		int j = i;
		while (j >= 0) {
			up(&full);
			up(&mutex);
			up(&full);
			up(&mutex);
			j--;
		}
		// Release locks for current thread and stop current thread
		printk(KERN_INFO "Stopping consumer thread PID-%d\n", cThread->task->pid);
		up(&full);
		up(&mutex);
		kthread_stop(cThread->task);
		up(&full);
		up(&mutex);
		cThread = cThread->next;
		
	}

	// Find the total elapsed time
	total_seconds = total_seconds / 1000000000;
	u64 minutes = total_seconds / 60;
	u64 hours = minutes / 60;
	u64 remain_seconds = total_seconds % 60;
	minutes = minutes % 60;
	printk(KERN_INFO "The total elapsed time of all processes for UID %d is %llu:%llu:%llu\n", uuid, hours, minutes, remain_seconds);

	printk(KERN_INFO "Exiting producer_consumer module\n");
}





module_init(procon_init);
module_exit(procon_exit);
MODULE_LICENSE("GPL");
