#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched/signal.h>
#include <linux/semaphore.h>
#include <linux/kthread.h>
#include <linux/timekeeping.h>
#include <linux/slab.h>


int buffSize;
int prod;
int cons;
int uuid;

module_param(buffSize, int, 0);
module_param(prod, int, 0 );
module_param(cons, int, 0);
module_param(uuid, int, 0);

struct task_struct_list {
	struct task_struct* task;
	struct task_struct_list* next; 
	};
	
struct buffer {

	int capacity;
	struct task_struct_list* list;
};


struct buffer *buf = NULL;
struct semaphore mutex;
struct semaphore full;
struct semaphore empty;
u64 total_seconds;
int consumed = 0;

struct task_struct *pThread;
int pThreadPID;
struct task_struct_list *cThreads = NULL;

/*
producer(void *arg) -- Producer thread function

Goes through a list of processes and adds processes
generated by user uuid to a shared buffer.
*/
static int producer(void *arg) {
	struct task_struct *ptr;
	int process_counter = 0;

	//Adds processes into buffer
	for_each_process(ptr) {
		if (ptr->cred->uid.val == uuid) {	// Process was generated by uuid
			process_counter++;	// Increment total processes
		
			if (down_interruptible(&empty))	// Acquire lock for empty
				break;
			if (down_interruptible(&mutex))	// Acquire lock for mutex
				break;	

			//Critical section - Add current task to buffer
			if (buf->list == NULL) {	// No tasks in buffer
				// Create new task_struct_list and add
				struct task_struct_list *new;
				new = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
				new->task = ptr;
				buf->list = new;

				/*!!!
				struct task_struct_list *newT;
				newT = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
				newT->task = ptr;
				buf->list = newT
				!!!*/

				buf->capacity++;
				printk(KERN_INFO "[%s] Produced Item#-%d at buffer index:%d for PID:%d", current->comm, process_counter, buf->capacity, new->task->pid);	// !!! newT->task->pid !!! //
			}
			else {	// Tasks exist in buffer
				// Find end of buffer task_struct_list
				struct task_struct_list *temp = buf->list;
				while (temp->next != NULL) {
					temp = temp->next;
				}
				// Create new task_struct_list and add
				struct task_struct_list *new;
				new = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
				new->task = ptr;
				temp->next = new;

				/*!!!
				struct task_struct_list *newT;
				newT = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
				newT->task = ptr;
				temp->next = newT
				!!!*/

				buf->capacity++;
				printk(KERN_INFO "[%s] Produced Item#-%d at buffer index:%d for PID:%d\n", current->comm, process_counter, buf->capacity, new->task->pid);	// !!! newT->task->pid !!! //
			}

			// Release locks
			up(&mutex);
			up(&full);
		}
	}

	return 0;	// Success
}

/*
consumer(void *arg) -- Consumer thread function

Takes tasks from the buffer (when available) and adds their elapsed time to
the total elapsed time.
*/
static int consumer(void *arg) {
	int consumedCount = 0;

	//Start infinite loop until stop
	while (!kthread_should_stop()) {
		if (down_interruptible(&full))	// Acquire lock from "full"
			break;
		if (down_interruptible(&mutex))	// Acquire lock from "mutex"
			break;


		//Check to skip critical section
		if (kthread_should_stop()) {
			/*!!!	Release locks that should be released anyways
			up(&mutex)
			up(&empty)
			!!!*/
			return 0;
		}

		// If the buffer contains at least 1 task
		if (buf != NULL && buf->list != NULL && buf->capacity > 0) {
			//Critical section - Take a task and add to elapsed time
			struct task_struct_list *temp = buf->list;
			buf->list = buf->list->next;
			u64 time_elapsed = ktime_get_ns() - temp->task->start_time;
			u64 elapsed_seconds = time_elapsed / 1000000000;
			int minutes = elapsed_seconds / 60;
			int hours = minutes / 60;
			int remaining_seconds = elapsed_seconds % 60;
			total_seconds = total_seconds + time_elapsed;
			//minutes = elapsed_seconds % 60;

			// increment amount consumed by this thread and all threads
			consumedCount++;
			consumed++;
			printk(KERN_INFO "[%s] Consumed Item#-%d on buffer index:%d for PID:%d Elapsed Time- %d:%d:%d\n", current->comm, consumedCount, buf->capacity, temp->task->pid, hours, minutes, remaining_seconds);

			buf->capacity--;	// Consume task

			// Release locks
			up(&mutex);	// !!! //
			up(&empty);
		}

		// !!! up(&mutex) !!! // move this statement here so that the mutex is guaranteed to be released (avoid deadlock)
	}

	return 0;	// Success
}

/*
procon_init(void) -- Module Initializing Method

Initializes variables used in the program.
Includes:
+ semaphores	(mutex,full,empty)
+ buffer		(buf)
+ producer		(pThread)
+ consumers		(cThreads)

Then prints PIDs of consumer threads
*/
static int __init procon_init(void) {
	int err;
	
	printk(KERN_INFO "Starting producer_consumer module\n");

	//Initialize Semaphores
	sema_init(&mutex, 1);
	sema_init(&full, 0);
	sema_init(&empty, buffSize);

	buf = kmalloc(sizeof(struct buffer), GFP_KERNEL);

	// START THREADS

	// Producer
	if (prod == 1) {
		pThread = kthread_run(producer, NULL, "Producer-1");
		pThreadPID = pThread->pid;

		if (IS_ERR(pThread)) {	// Producer creation error
			printk(KERN_INFO "ERROR: Cannot create producer thread\n");
			err = PTR_ERR(pThread);
			pThread = NULL;
			return err;
		}
	}
	
	// Consumer
	int i = 0;
	while (i < cons) {
		// Construct individual cThread using task_struct_list 
		struct task_struct_list *cThread = kmalloc(sizeof(struct task_struct_list), GFP_KERNEL);
		cThread->task = kthread_run(consumer, NULL, "Consumer-%d", i);

		if (IS_ERR(cThread->task)) {	// Consumer creation error
			printk(KERN_INFO "ERROR: Cannot create consumer thread\n");
			err = PTR_ERR(cThread->task);
			cThread->task = NULL;
			return err;
		}

		// Attach new thread as head of cThreads list
		cThread->next = cThreads;
		cThreads = cThread;

		i++;
	}

	// Go through each thread in cThreads and print PID
	struct task_struct_list *cThr = cThreads;
	while (cThr != NULL) {
		printk(KERN_INFO "consumer thread PID %d\n", cThr->task->pid);
		cThr = cThr->next;
	}

	return 0;	// Successs
}

/*
procon_exit(void) -- Module exit Method

Frees memory for all threads and releases semaphores
*/
static void __exit procon_exit(void) {
	// Free buffer memory
	struct task_struct_list *temp = buf->list;
	while (temp != NULL) {
		// !!! up(&empty) !!! //
		struct task_struct_list *tbr = temp;
		temp = temp->next;
		kfree(tbr);
	}
	kfree(buf);

	printk(KERN_INFO "Stopping producer thread PID-%d\n", pThreadPID);

	// Halt consumer threads
	int i = cons;
	struct task_struct_list *cThread = cThreads;
	// !!! Why have up functions in this loop instead of dealing with the locks in the threads? !!! //
	while (cThread != NULL) {
		int j = i;
		while (j >= 0) {
			up(&full);
			up(&mutex);
			up(&full);
			up(&mutex);
			j--;
		}
		// Release locks for current thread and stop current thread
		printk(KERN_INFO "Stopping consumer thread PID-%d\n", cThread->task->pid);
		up(&full);
		up(&mutex);
		kthread_stop(cThread->task);
		up(&full);
		up(&mutex);
		cThread = cThread->next;
		
	}

	// Find elapsed time
	total_seconds = total_seconds / 1000000000;
	int minutes = total_seconds / 60;
	int hours = minutes / 60;
	int remain_seconds = total_seconds % 60;
	minutes = minutes % 60;
	printk(KERN_INFO "The total elapsed time of all processes for UID %d is %d:%d:%d\n", uuid, hours, minutes, remain_seconds);

	printk(KERN_INFO "Exiting producer_consumer module\n");
}





module_init(procon_init);
module_exit(procon_exit);
MODULE_LICENSE("GPL");
